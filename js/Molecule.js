/*
 * MolPaintJS
 * Copyright 2017 Leibniz-Institut f. Pflanzenbiochemie 
 *  
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *  
 */

function Molecule() {

    this.properties = {};

    this.properties["COMMENT"] = "generated by MolPaintJS";
    this.properties["HEADER2"] = "";
    this.properties["NAME"] = "n.n.";

    this.atoms = {};
    this.bonds = {};
    this.atomCount = 0;
    this.bondCount = 0;
    this.atomObjCount = 0;	// unique counter for atoms
    this.bondObjCount = 0;	// unique counter for bonds

    this.addAtom = function (a, id) {
        this.atomObjCount++;
        if (id == null) {
            id = "Atom" + this.atomObjCount;
            a.setId(id);
        }
        this.atoms[id] = a;
        return id;
    }

    this.addBond = function (b, id) {
        this.bondObjCount++;
        if (id == null) {
            id = "Bond" + this.bondObjCount;
            b.setId(id);
        }
        this.bonds[id] = b;
        b.atomA.addBond(id);
        b.atomB.addBond(id);
        return id;
    }

    /**
     * adjust selections
     * @param match match all atoms and bonds where any of the given bits are set
     * @param clear clear given bits on all matching atoms and bonds
     * @param set Set the given bits on all matching atoms and bonds
     */
    this.adjustSelection = function (match, clear, set) {
        for (var id in this.atoms) {
            if(this.atoms[id].selected & match) {

                // order matters: first clear, then set
                this.atoms[id].selected &= ~clear;
                this.atoms[id].selected |= set;
            } 
        }
        for (var id in this.bonds) {
            if(this.bonds[id].selected & match) {
                this.bonds[id].selected &= ~clear;
                this.bonds[id].selected |= set;
            }
        }
    }

    /**
     * center the molecule according to its bounding box
     * i.e. move the center of the molecule to the point 0,0
     * @return the updated bounding box
     */
    this.center = function () {
        var bbox = this.computeBBox(0);

        for (var id in this.atoms) {
            this.atoms[id].coordX -= bbox.centerX;
            this.atoms[id].coordY -= bbox.centerY;
            // ignore z
        }

        bbox.minX -= bbox.centerX;
        bbox.maxX -= bbox.centerX;
        bbox.minY -= bbox.centerY;
        bbox.maxY -= bbox.centerY;
        bbox.centerX = 0.0;
        bbox.centerY = 0.0;
        return bbox;
    }

    /**
     * clear all selections
     * @param val All selections with bit val will be cleared. 
     */
    this.clearSelection = function (val) {
        for (var id in this.atoms) {
            if(this.atoms[id].selected & val) {
                this.atoms[id].selected &= ~val;
            }
        }
        for (var id in this.bonds) {
            if(this.bonds[id].selected & val) {
                this.bonds[id].selected &= ~val;
            }
        }
    }

    /**
     * compute update history and clear temp flag 
     * @return actionList containing update history
     */
    this.clearTemp = function ()  {
        var actionList = new ActionList();

        for (var id in this.atoms) {
            if(this.atoms[id].temp) {
                this.atoms[id].temp = 0;
                actionList.addAction(new Action("ADD", "ATOM", this.atoms[id], null));
            }
        }
        for (var id in this.bonds) {
            if(this.bonds[id].temp) {
                this.bonds[id].temp = 0;
                actionList.addAction(new Action("ADD", "BOND", this.bonds[id], null));
            }
        }
        return actionList;
    }

    /**
     * compute the bounding box coordinates of the current molecule
     * @param sel select bits which must be set when computing the 
     * bounding box; if sel = 0, everything is selected
     */
    this.computeBBox = function (sel) {
        var bbox = {
            centerX: 0.0, centerY: 0.0, centerZ: 0.0,
            maxX: 0.0, maxY: 0.0, maxZ: 0.0,
            minX: 0.0, minY: 0.0, minZ: 0.0
        };
        var first = 0;

        for (var i in this.atoms) {
            var a = this.atoms[i];
            if ((sel === 0) || ((a.selected & sel) != 0)) {
                var x = a.coordX;
                var y = a.coordY;
                var z = a.coordZ;
                if (first == 0) {
                    bbox.maxX = x;
                    bbox.minX = x;
                    bbox.maxY = y;
                    bbox.minY = y;
                    bbox.maxZ = z;
                    bbox.minZ = z;
                    first = 1;
                } else {
                    bbox.minX = (bbox.minX > x) ? x : bbox.minX;
                    bbox.minY = (bbox.minY > y) ? y : bbox.minY;
                    bbox.minZ = (bbox.minZ > z) ? z : bbox.minZ;
                    bbox.maxX = (bbox.maxX < x) ? x : bbox.maxX;
                    bbox.maxY = (bbox.maxY < y) ? y : bbox.maxY;
                    bbox.maxZ = (bbox.maxZ < z) ? z : bbox.maxZ;
                }
            }
        }
        var d = bbox.maxX - bbox.minX;
        bbox.centerX = bbox.minX + (d / 2);
        d = bbox.maxY - bbox.minY;
        bbox.centerY = bbox.minY + (d / 2);
        d = bbox.maxZ - bbox.minZ;
        bbox.centerZ = bbox.minZ + (d / 2);

        return bbox;
    }

    /**
     * computes the median bond length in this molecule
     */
    this.computeBondLengths = function () {
        var bondLength = [];
        for (var i in this.bonds) {
            var b = this.bonds[i];
            var dx = b.atomA.coordX - b.atomB.coordX;
            var dy = b.atomA.coordY - b.atomB.coordY;
            var lensq = (dx * dx) + (dy * dy);
            bondLength.push(lensq);
        }
        bondLength.sort(function (a, b) {
            return a - b;
        });
        if (bondLength.length > 0) {
            return Math.sqrt(bondLength[Math.floor(bondLength.length / 2)]);
        }
        return 1.5;	// default bond length
    }

    /**
     * deletes a single atom from this molecule
     * CAVEAT: this function does not perform any cross-check,
     * whether this atom is still part of a bond in this
     * molecule
     */
    this.delAtom = function (a) {
        var idx = a.id;
        delete this.atoms[idx];
    }

    this.delBond = function (b) {
        var idx = b.id;
        var b = this.bonds[idx];
        b.atomA.delBond(idx);
        b.atomB.delBond(idx);
        delete this.bonds[idx];
    }

    /**
     * delete all temporary bonds and atoms from the molecule
     */
    this.delTemp = function() {
        for(var b in this.bonds) {
            if(this.bonds[b].temp) {
                this.bonds[b].atomA.delBond(b);
                this.bonds[b].atomB.delBond(b);
                delete this.bonds[b]; 
            }
        }
        for(var a in this.atoms) {
            if(this.atoms[a].temp) {
                delete this.atoms[a]; 
            }
        }
    }

    this.getAtom = function (id) {
        return this.atoms[id];
    }
    this.getAtomCount = function () {
        return this.atomCount;
    }
    this.getAtoms = function () {
        return this.atoms;
    }
    this.getBond = function (id) {
        return this.bonds[id];
    }
    this.getBondCount = function () {
        return this.bondCount;
    }
    this.getBonds = function () {
        return this.bonds;
    }

    this.getProperties = function () {
        return this.properties;
    }
    this.getProperty = function (propname) {
        return this.properties[propname];
    }

    /**
     * @param sel selection bits
     * @return the atoms and bonds which match the given selection bits
     */
    this.getSelected = function (sel) {
        var result = {atoms: [], bonds: []};
        for (var id in this.atoms) {
            if ((this.atoms[id].selected & sel) != 0) {
                result.atoms.push(id);
            }
        }
        for (var id in this.bonds) {
            if ((this.bonds[id].selected & sel) != 0) {
                result.bonds.push(id);
            }
        }
        return result;
    }

    /**
     * assign a numeric index to all atoms and bonds
     */
    this.reIndex = function () {
        var i = 1;
        for (var id in this.atoms) {
            var a = this.atoms [id];
            a.setIndex(i);
            i++;
        }
        this.atomCount = i - 1;

        i = 1;
        for (var id in this.bonds) {
            var b = this.bonds[id];
            b.setIndex(i);
            i++;
        }
        this.bondCount = i - 1;
    }

    /**
     * replace an atom in the atom list and all
     * bonds. The IDs of the atoms must be identical.
     * @param a atom
     */
    this.replaceAtom = function (a) {
        var id = a.getId();
        var o = this.atoms[id];
        if (o == null) {
            alert("Molecule.replaceAtom() called for non-existing atom.");
            return;
        }
        for (var i in o.bonds) {
            var b = this.bonds[i];
            if (b.atomA.getId() == id) {
                b.atomA = a;
            } else {
                b.atomB = a;
            }
        }
        this.atoms[id] = a;
    }

    /**
     * replace a bond in the bond list. The IDs of the
     * bonds must be identical. The bond lists
     * of the atoms are not affected, because they contain
     * only bond IDs.
     */
    this.replaceBond = function (b) {
        var id = b.getId();
        var o = this.bonds[id];
        if (o == null) {
            alert("Molecule.replaceBond() called for non-existing bond.");
            return;
        }
        this.bonds[id] = b;
    }

    /**
     * select the first matching atom
     * @param coords the coordinates
     * @param distmax maximum squared euclidian distance 
     * @return atomId
     */
    this.selectAtom = function (coords, distmax) {
        for (var id in this.atoms) {
            var a = this.atoms[id];
            var dx = a.coordX - coords.x;
            var dy = a.coordY - coords.y;
            if (distmax > ((dx * dx) + (dy * dy))) {
                return id;
            }
        }
        return null;
    }

    /**
     * return a list of atom id's and a list of bond id's,
     * which are enclosed by the given bounding box.
     * Enclosed atoms and bonds are marked as selected.
     * @param bbox bounding box in molecule coordinates
     * @param val bit value to set on selected entities 
     * @param cond bits which must not be set for selection of an entity
     * @return an object with properties "atoms" and "bonds"
     */
    this.selectBBox = function (bbox, val, cond) {
        var result = {atoms: [], bonds: []};
        for (var id in this.atoms) {
            var atom = this.atoms[id];
            if ((atom.selected & cond) === 0) {
                var x = atom.coordX;
                var y = atom.coordY;
                if ((bbox.minX < x) && (x < bbox.maxX)
                    && (bbox.minY < y) && (y < bbox.maxY)) {
                    atom.selected |= val;
                    result.atoms.push(id);
                }
            }
        }
        for (var id in this.bonds) {
            var bond = this.bonds[id];
            if ((bond.selected & cond) === 0) {
                var atomA = bond.atomA;
                var atomB = bond.atomB;
                var xA = atomA.coordX;
                var xB = atomB.coordX;
                var yA = atomA.coordY;
                var yB = atomB.coordY;
                if ((bbox.minX < xA) && (xA < bbox.maxX)
                    && (bbox.minY < yA) && (yA < bbox.maxY)
                    && (bbox.minX < xB) && (xB < bbox.maxX)
                    && (bbox.minY < yB) && (yB < bbox.maxY)) {
                    bond.selected |= val;
                    result.bonds.push(id);
                }
            }
        }
        return result;
    }

    /**
     * return a list of matching bonds
     * @param coords coordinates of action
     * @param distmax maximum squared euclidian distance 
     * @param returns an array of matching bonds; array may be empty
     */
    this.selectBond = function (coords, distmax) {
        var matches = [];
        for (var id in this.bonds) {
            var b = this.bonds[id];
            var dx = b.atomA.coordX - b.atomB.coordX;
            var dy = b.atomA.coordY - b.atomB.coordY;
            var l = Math.sqrt(dx * dx + dy * dy);

            l = (l < 0.01) ? 1.0 : l;   // guard against division by zero

            var bx = coords.x - b.atomB.coordX;
            var by = coords.y - b.atomB.coordY;

            var sin = dy / l;
            var cos = dx / l;

            var rx = bx * cos + by * sin;
            var ry = -bx * sin + by * cos

            if ((rx > 0) && (rx < l) && ((ry * ry) < distmax)) {
                matches.push(id);
            }

        }
        return matches;
    }

    this.setProperty = function (propname, propval) {
        this.properties[propname] = propval;
    }

    /**
     * 2d-transforms the coordinates of this molecule.
     * The z-coordinate is not affected!
     * @param matrix a 2x3 transformation matrix
     * @param sel select bits to which the transformation should apply (set to 
     * zero to apply transformation to all atoms) 
     */
    this.transform = function (matrix, sel) {
        for (var id in this.atoms) {
            var atom = this.atoms[id];
            if ( (sel === 0) || ((atom.selected & sel) != 0)) {
                var x = atom.coordX;
                var y = atom.coordY;
                atom.coordX = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2];
                atom.coordY = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2];
            }
        }
    }
}
